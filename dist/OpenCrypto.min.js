"use strict";function _instanceof(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):e instanceof t}function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _classCallCheck(e,t){if(!_instanceof(e,t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),e}var cryptoLib=window.crypto||window.msCrypto,cryptoApi=cryptoLib.subtle||cryptoLib.webkitSubtle,chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256),PBES2_OID="06092a864886f70d01050d",PBKDF2_OID="06092a864886f70d01050c",AES256GCM_OID="060960864801650304012e",AES192GCM_OID="060960864801650304011a",AES128GCM_OID="0609608648016503040106",AES256CBC_OID="060960864801650304012a",AES192CBC_OID="0609608648016503040116",AES128CBC_OID="0609608648016503040102",AES256CFB_OID="060960864801650304012c",AES192CFB_OID="0609608648016503040118",AES128CFB_OID="06086086480165030404",SHA512_OID="06082a864886f70d020b0500",SHA384_OID="06082a864886f70d020a0500",SHA256_OID="06082a864886f70d02090500",SHA1_OID="06082a864886f70d02070500",RSA_OID="06092a864886f70d010101",EC_OID="06072a8648ce3d0201",P256_OID="06082a8648ce3d030107",P384_OID="06052b81040022",P521_OID="06052b81040023",OpenCrypto=function(){function e(){_classCallCheck(this,e);for(var t=0;t<chars.length;t++)lookup[chars.charCodeAt(t)]=t}return _createClass(e,[{key:"encodeAb",value:function(e){for(var t=new Uint8Array(e),r=t.length,n="",o=0;o<r;o+=3)n+=chars[t[o]>>2],n+=chars[(3&t[o])<<4|t[o+1]>>4],n+=chars[(15&t[o+1])<<2|t[o+2]>>6],n+=chars[63&t[o+2]];return r%3==2?n=n.substring(0,n.length-1)+"=":r%3==1&&(n=n.substring(0,n.length-2)+"=="),n}},{key:"decodeAb",value:function(e){var t,r,n,o,a=e.length,i=.75*e.length,p=0;"="===e[e.length-1]&&(i--,"="===e[e.length-2]&&i--);for(var y=new ArrayBuffer(i),s=new Uint8Array(y),c=0;c<a;c+=4)t=lookup[e.charCodeAt(c)],r=lookup[e.charCodeAt(c+1)],n=lookup[e.charCodeAt(c+2)],o=lookup[e.charCodeAt(c+3)],s[p++]=t<<2|r>>4,s[p++]=(15&r)<<4|n>>2,s[p++]=(3&n)<<6|63&o;return y}},{key:"arrayBufferToString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");return new TextDecoder("utf-8").decode(e)}},{key:"stringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input to be a String");return new TextEncoder("utf-8").encode(e).buffer}},{key:"arrayBufferToHexString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");for(var t,r=new Uint8Array(e),n="",o=0;o<r.byteLength;o++)(t=r[o].toString(16)).length<2&&(t="0"+t),n+=t;return n}},{key:"hexStringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input of hexString to be a String");if(e.length%2!=0)throw new RangeError("Expected string to be an even number of characters");for(var t=new Uint8Array(e.length/2),r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}},{key:"arrayBufferToBase64",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input to be an ArrayBuffer Object");return this.encodeAb(e)}},{key:"base64ToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input to be a base64 String");return this.decodeAb(e)}},{key:"decimalToHex",value:function(e,t){t=void 0!==t&&t;var r=null;return"number"==typeof e?t?(r=e.toString(16)).length%2?"000"+r:"00"+r:(r=e.toString(16)).length%2?"0"+r:r:"string"==typeof e?(r=(e.length/2).toString(16)).length%2?"0"+r:r:void 0}},{key:"addNewLines",value:function(e){for(var t="";e.length>0;)t+=e.substring(0,64)+"\r\n",e=e.substring(64);return t}},{key:"removeLines",value:function(e){return e.replace(/\r?\n|\r/g,"")}},{key:"toAsn1",value:function(e,t,r,n,o,a,i){e=this.arrayBufferToHexString(e),t=this.arrayBufferToHexString(t),r=this.arrayBufferToHexString(r),n=this.decimalToHex(n,!0);var p={};switch(o){case"SHA-512":p.HASH_OID=SHA512_OID;break;case"SHA-384":p.HASH_OID=SHA384_OID;break;case"SHA-256":p.HASH_OID=SHA256_OID;break;case"SHA-1":p.HASH_OID=SHA1_OID}switch(a){case"AES-GCM":256===i?p.CIPHER_OID=AES256GCM_OID:192===i?p.CIPHER_OID=AES192GCM_OID:128===i&&(p.CIPHER_OID=AES128GCM_OID);break;case"AES-CBC":256===i?p.CIPHER_OID=AES256CBC_OID:192===i?p.CIPHER_OID=AES192CBC_OID:128===i&&(p.CIPHER_OID=AES128CBC_OID);break;case"AES-CFB":256===i?p.CIPHER_OID=AES256CFB_OID:192===i?p.CIPHER_OID=AES192CFB_OID:128===i&&(p.CIPHER_OID=AES128CFB_OID)}var y="02"+this.decimalToHex(n.length/2)+n,s="04"+this.decimalToHex(t)+t,c="04"+this.decimalToHex(r)+r,f="04"+(this.decimalToHex(e).length/2==2?"82":"81")+this.decimalToHex(e)+e;p.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(p.CIPHER_OID+c),p.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(p.HASH_OID),p.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(s+y+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+s+y+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+s+y+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c),p.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+s+y+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c);var u=p.SEQUENCE_PBES2_CONTAINER+PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+s+y+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+c,h=this.decimalToHex(u+f),E="30"+(h.length/2==2?"82":"81")+h+u+f,d=this.hexStringToArrayBuffer(E),g=this.arrayBufferToBase64(d);return g="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+(g=this.addNewLines(g))+"-----END ENCRYPTED PRIVATE KEY-----"}},{key:"fromAsn1",value:function(e){var t={};e=(e=(e=this.removeLines(e)).replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","")).replace("-----END ENCRYPTED PRIVATE KEY-----",""),e=this.base64ToArrayBuffer(e);var r=this.arrayBufferToHexString(e);return t.data=r,t.data.includes(PBES2_OID)&&t.data.includes(PBKDF2_OID)&&(t.valid=!0),t.saltBegin=t.data.indexOf(PBKDF2_OID)+28,t.data.includes(AES256GCM_OID)?(t.cipher="AES-GCM",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256GCM_OID)+24):t.data.includes(AES192GCM_OID)?(t.cipher="AES-GCM",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192GCM_OID)+24):t.data.includes(AES128GCM_OID)?(t.cipher="AES-GCM",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128GCM_OID)+24):t.data.includes(AES256CBC_OID)?(t.cipher="AES-CBC",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256CBC_OID)+24):t.data.includes(AES192CBC_OID)?(t.cipher="AES-CBC",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192CBC_OID)+24):t.data.includes(AES128CBC_OID)?(t.cipher="AES-CBC",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128CBC_OID)+24):t.data.includes(AES256CFB_OID)?(t.cipher="AES-CFB",t.keyLength=256,t.ivBegin=t.data.indexOf(AES256CFB_OID)+24):t.data.includes(AES192CFB_OID)?(t.cipher="AES-CFB",t.keyLength=192,t.ivBegin=t.data.indexOf(AES192CFB_OID)+24):t.data.includes(AES128CFB_OID)&&(t.cipher="AES-CFB",t.keyLength=128,t.ivBegin=t.data.indexOf(AES128CFB_OID)+22),t.data.includes(SHA512_OID)?t.hash="SHA-512":t.data.includes(SHA384_OID)?t.hash="SHA-384":t.data.includes(SHA256_OID)?t.hash="SHA-256":t.data.includes(SHA1_OID)&&(t.hash="SHA-1"),t.saltLength=parseInt(t.data.substr(t.saltBegin,2),16),t.ivLength=parseInt(t.data.substr(t.ivBegin,2),16),t.salt=t.data.substr(t.saltBegin+2,2*t.saltLength),t.iv=t.data.substr(t.ivBegin+2,2*t.ivLength),t.iterBegin=t.saltBegin+4+2*t.saltLength,t.iterLength=parseInt(t.data.substr(t.iterBegin,2),16),t.iter=parseInt(t.data.substr(t.iterBegin+2,2*t.iterLength),16),t.sequencePadding="81"===t.data.substr(2,2)?8:10,t.parametersPadding="81"===t.data.substr(2,2)?12:16,t.sequenceLength=parseInt(t.data.substr(t.sequencePadding,2),16),t.encryptedDataBegin=t.parametersPadding+2*t.sequenceLength,t.encryptedDataPadding="81"===t.data.substr(t.encryptedDataBegin-2,2)?2:4,t.encryptedDataLength=parseInt(t.data.substr(t.encryptedDataBegin,6),16),t.encryptedData=t.data.substr(t.encryptedDataBegin+t.encryptedDataPadding,2*t.encryptedDataLength),{salt:this.hexStringToArrayBuffer(t.salt),iv:this.hexStringToArrayBuffer(t.iv),cipher:t.cipher,keyLength:t.keyLength,hash:t.hash,iter:t.iter,encryptedData:this.hexStringToArrayBuffer(t.encryptedData)}}},{key:"getRSAKeyPair",value:function(e,t,r,n,o){return e=void 0!==e?e:2048,t=void 0!==t?t:"SHA-512",r=void 0!==r?r:"RSA-OAEP",n=void 0!==n?n:["encrypt","decrypt","wrapKey","unwrapKey"],o=void 0===o||o,new Promise(function(a,i){if("number"!=typeof e)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof t)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof r)throw new TypeError("Expected input of paddingScheme to be a String");if("object"!==_typeof(n))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof o)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:r,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:t}},o,n).then(function(e){a(e)}).catch(function(e){i(e)})})}},{key:"rsaEncrypt",value:function(e,t){var r=this;return new Promise(function(n,o){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type public");if("object"!==_typeof(t))throw new TypeError("Expected input of data to be an ArrayBuffer");cryptoApi.encrypt({name:"RSA-OAEP"},e,t).then(function(e){n(r.arrayBufferToBase64(e))}).catch(function(e){o(e)})})}},{key:"rsaDecrypt",value:function(e,t){var r=this;return new Promise(function(n,o){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type private");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a String");cryptoApi.decrypt({name:"RSA-OAEP"},e,r.base64ToArrayBuffer(t)).then(function(e){n(e)}).catch(function(e){o(e)})})}},{key:"getECKeyPair",value:function(e,t,r,n){return e=void 0!==e?e:"P-256",t=void 0!==t?t:"ECDH",r=void 0!==r?r:["deriveKey","deriveBits"],n=void 0===n||n,new Promise(function(o,a){if("string"!=typeof e)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof t)throw new TypeError("Expected input of type to be a String");if("object"!==_typeof(r))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof n)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:t,namedCurve:e},n,r).then(function(e){o(e)}).catch(function(e){a(e)})})}},{key:"cryptoPrivateToPem",value:function(e){var t=this;return new Promise(function(r,n){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("pkcs8",e).then(function(e){var n=t.arrayBufferToBase64(e),o=t.addNewLines(n);r(o="-----BEGIN PRIVATE KEY-----\r\n"+o+"-----END PRIVATE KEY-----")}).catch(function(e){n(e)})})}},{key:"pemPrivateToCrypto",value:function(e,t){var r=this;return new Promise(function(n,o){if(void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,"string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");e=(e=e.replace("-----BEGIN PRIVATE KEY-----","")).replace("-----END PRIVATE KEY-----","");var a=r.removeLines(e),i=r.base64ToArrayBuffer(a),p=r.arrayBufferToHexString(i),y=null;if(p.includes(EC_OID)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");var s=null;if(p.includes(P256_OID)?s="P-256":p.includes(P384_OID)?s="P-384":p.includes(P521_OID)&&(s="P-521"),"ECDH"===t.name){if(t.usages=void 0!==t.usages?t.usages:["deriveKey","deriveBits"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be a String")}else{if("ECDSA"!==t.name)throw new TypeError("Invalid algorithm name");if(t.usages=void 0!==t.usages?t.usages:["sign"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be a String")}y={name:t.name,namedCurve:s}}else{if(!p.includes(RSA_OID))throw new TypeError("Invalid private key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name){if(t.usages=void 0!==t.usages?t.usages:["decrypt","unwrapKey"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be an Array")}else{if("RSA-PSS"!==t.name)throw new TypeError("Invalid algorithm name");if(t.usages=void 0!==t.usages?t.usages:["sign"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be a String")}y={name:t.name,hash:{name:t.hash}}}cryptoApi.importKey("pkcs8",i,y,t.isExtractable,t.usages).then(function(e){n(e)}).catch(function(e){o(e)})})}},{key:"cryptoPublicToPem",value:function(e){var t=this;return new Promise(function(r,n){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("spki",e).then(function(e){var n=t.arrayBufferToBase64(e),o=t.addNewLines(n);r(o="-----BEGIN PUBLIC KEY-----\r\n"+o+"-----END PUBLIC KEY-----")}).catch(function(e){n(e)})})}},{key:"pemPublicToCrypto",value:function(e,t){var r=this;return new Promise(function(n,o){if(void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,"string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");e=(e=e.replace("-----BEGIN PUBLIC KEY-----","")).replace("-----END PUBLIC KEY-----","");var a=r.removeLines(e),i=r.base64ToArrayBuffer(a),p=r.arrayBufferToHexString(i),y=null;if(p.includes(EC_OID)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");var s=null;if(p.includes(P256_OID)?s="P-256":p.includes(P384_OID)?s="P-384":p.includes(P521_OID)&&(s="P-521"),"ECDH"===t.name){if(t.usages=void 0!==t.usages?t.usages:[],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be a String")}else{if("ECDSA"!==t.name)throw new TypeError("Invalid algorithm name");if(t.usages=void 0!==t.usages?t.usages:["verify"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be a String")}y={name:t.name,namedCurve:s}}else{if(!p.includes(RSA_OID))throw new TypeError("Invalid public key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name){if(t.usages=void 0!==t.usages?t.usages:["encrypt","wrapKey"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be an Array")}else{if("RSA-PSS"!==t.name)throw new TypeError("Invalid algorithm name");if(t.usages=void 0!==t.usages?t.usages:["verify"],"object"!==_typeof(t.usages))throw new TypeError("Expected input of options.usages to be an Array")}y={name:t.name,hash:{name:t.hash}}}cryptoApi.importKey("spki",i,y,t.isExtractable,t.usages).then(function(e){n(e)}).catch(function(e){o(e)})})}},{key:"encryptPrivateKey",value:function(e,t,r,n,o,a){var i=this;return r=void 0!==r?r:64e3,n=void 0!==n?n:"SHA-512",o=void 0!==o?o:"AES-GCM",a=void 0!==a?a:256,new Promise(function(p,y){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof n)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof o)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof a)throw new TypeError("Expected input of keyLength to be a Number");var s=null;"AES-GCM"===o?s=12:"AES-CBC"===o?s=16:"AES-CFB"===o&&(s=16);var c=cryptoLib.getRandomValues(new Uint8Array(16)),f=cryptoLib.getRandomValues(new Uint8Array(s));cryptoApi.importKey("raw",i.stringToArrayBuffer(t),{name:"PBKDF2"},!1,["deriveKey"]).then(function(t){cryptoApi.deriveKey({name:"PBKDF2",salt:c,iterations:r,hash:n},t,{name:o,length:a},!0,["wrapKey"]).then(function(t){cryptoApi.wrapKey("pkcs8",e,t,{name:o,iv:f}).then(function(e){var t=i.toAsn1(e,c,f,r,n,o,a);p(t)}).catch(function(e){y(e)})}).catch(function(e){y(e)})}).catch(function(e){y(e)})})}},{key:"decryptPrivateKey",value:function(e,t,r){var n=this,o=this.fromAsn1(e);return new Promise(function(a,i){void 0===r&&(r={});var p={};if(r.name=void 0!==r.name?r.name:"ECDH",r.isExtractable=void 0===r.isExtractable||r.isExtractable,p.name=r.name,"ECDH"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["deriveKey","deriveBits"],p.namedCurve=r.namedCurve,"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String")}else if("ECDSA"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["sign"],p.namedCurve=r.namedCurve,"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String")}else if("RSA-OAEP"===r.name){if(r.hash=void 0!==r.hash?r.hash:{},r.hash.name=void 0!==r.hash.name?r.hash.name:"SHA-512",r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["decrypt","unwrapKey"],p.hash={},p.hash.name=r.hash.name,"string"!=typeof r.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String")}else{if("RSA-PSS"!==r.name)throw new TypeError("Unsupported encryptedPrivateKey");if(r.hash=void 0!==r.hash?r.hash:{},r.hash.name=void 0!==r.hash.name?r.hash.name:"SHA-512",r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["sign"],p.hash={},p.hash.name=r.hash.name,"string"!=typeof r.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String")}if("string"!=typeof e)throw new TypeError("Expected input of encryptedPrivateKey to be a base64 String");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(r.keyUsages))throw new TypeError("Expected input of options.keyUsages to be a String");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.importKey("raw",n.stringToArrayBuffer(t),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:o.salt,iterations:o.iter,hash:o.hash},e,{name:o.cipher,length:o.keyLength},!1,["unwrapKey"]).then(function(e){cryptoApi.unwrapKey("pkcs8",o.encryptedData,e,{name:o.cipher,iv:o.iv},p,r.isExtractable,r.keyUsages).then(function(e){a(e)}).catch(function(e){i(e)})}).catch(function(e){i(e)})}).catch(function(e){i(e)})})}},{key:"encryptKey",value:function(e,t,r){var n=this;return new Promise(function(o,a){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of wrappingKey to be a CryptoKey of type public");if("[object CryptoKey]"!==Object.prototype.toString.call(t)&&"secret"!==t.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey of type secret");if("ECDH"===e.algorithm.name){if(void 0===r&&(r={}),r.derivedKeyCipher=void 0!==r.derivedKeyCipher?r.derivedKeyCipher:"AES-GCM",r.derivedKeyLength=void 0!==r.derivedKeyLength?r.derivedKeyLength:256,"[object CryptoKey]"!==Object.prototype.toString.call(r.privateKey)&&"private"!==r.privateKey.type)throw new TypeError("Expected input of options.privateKey to be a CryptoKey of type private");if("string"!=typeof r.derivedKeyCipher)throw new TypeError("Expected input of options.derivedKeyCipher to be a String");if("number"!=typeof r.derivedKeyLength)throw new TypeError("Expected input of options.derivedKeyLength to be a Number");cryptoApi.deriveKey({name:"ECDH",namedCurve:e.algorithm.namedCurve,public:e},r.privateKey,{name:r.derivedKeyCipher,length:r.derivedKeyLength},!1,["wrapKey"]).then(function(e){var r=cryptoLib.getRandomValues(new Uint8Array(12));cryptoApi.wrapKey("raw",t,e,{name:e.algorithm.name,iv:r,tagLength:128}).then(function(e){o(n.arrayBufferToBase64(r)+n.arrayBufferToBase64(e))}).catch(function(e){a(e)})}).catch(function(e){a(e)})}else if("RSA-OAEP"===e.algorithm.name){if(void 0===r&&(r={}),"[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey of type public");cryptoApi.wrapKey("raw",t,e,{name:"RSA-OAEP",hash:{name:e.algorithm.hash.name}}).then(function(e){o(n.arrayBufferToBase64(e))}).catch(function(e){a(e)})}else{if("AES-GCM"!==e.algorithm.name)throw new TypeError("Unsupported wrappingKey");var i=cryptoLib.getRandomValues(new Uint8Array(12));cryptoApi.wrapKey("raw",t,e,{name:e.algorithm.name,iv:i,tagLength:128}).then(function(e){o(n.arrayBufferToBase64(i)+n.arrayBufferToBase64(e))}).catch(function(e){a(e)})}})}},{key:"decryptKey",value:function(e,t,r){var n=this;return new Promise(function(o,a){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey of type private");if("string"!=typeof t)throw new TypeError("Expected input of encryptedSharedKey to be a base64 String");if("ECDH"===e.algorithm.name){if(void 0===r&&(r={}),r.derivedKeyCipher=void 0!==r.derivedKeyCipher?r.derivedKeyCipher:"AES-GCM",r.derivedKeyLength=void 0!==r.derivedKeyLength?r.derivedKeyLength:256,r.keyCipher=void 0!==r.keyCipher?r.keyCipher:"AES-GCM",r.keyLength=void 0!==r.keyLength?r.keyLength:256,r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],r.isExtractable=void 0===r.isExtractable||r.isExtractable,"[object CryptoKey]"!==Object.prototype.toString.call(r.publicKey)&&"public"!==r.publicKey.type)throw new TypeError("Expected input of options.publicKey to be a CryptoKey of type public");if("string"!=typeof r.derivedKeyCipher)throw new TypeError("Expected input of options.derivedKeyCipher to be a String");if("number"!=typeof r.derivedKeyLength)throw new TypeError("Expected input of options.derivedKeyLength to be a Number");if("string"!=typeof r.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof r.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(r.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var i=t.substring(0,16);t=t.substring(16);var p=n.base64ToArrayBuffer(i),y=n.base64ToArrayBuffer(t);cryptoApi.deriveKey({name:"ECDH",namedCurve:e.algorithm.namedCurve,public:r.publicKey},e,{name:r.derivedKeyCipher,length:r.derivedKeyLength},!1,["unwrapKey"]).then(function(e){cryptoApi.unwrapKey("raw",y,e,{name:e.algorithm.name,iv:p,tagLength:128},{name:r.keyCipher,length:r.keyLength},r.isExtractable,r.keyUsages).then(function(e){o(e)}).catch(function(e){a(e)})}).catch(function(e){a(e)})}else if("RSA-OAEP"===e.algorithm.name){if(void 0===r&&(r={}),r.keyCipher=void 0!==r.keyCipher?r.keyCipher:"AES-GCM",r.keyLength=void 0!==r.keyLength?r.keyLength:256,r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],r.isExtractable=void 0===r.isExtractable||r.isExtractable,"string"!=typeof r.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof r.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(r.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");var s=n.base64ToArrayBuffer(t);cryptoApi.unwrapKey("raw",s,e,{name:"RSA-OAEP",modulusLength:e.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:e.algorithm.hash.name}},{name:r.keyCipher,length:r.keyLength},r.isExtractable,r.keyUsages).then(function(e){o(e)}).catch(function(e){a(e)})}else{if("AES-GCM"!==e.algorithm.name)throw new TypeError("Unsupported unwrappingKey");if(void 0===r&&(r={}),r.keyCipher=void 0!==r.keyCipher?r.keyCipher:"AES-GCM",r.keyLength=void 0!==r.keyLength?r.keyLength:256,r.keyUsages=void 0!==r.keyUsages?r.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],r.isExtractable=void 0===r.isExtractable||r.isExtractable,"string"!=typeof r.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof r.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(r.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var c=t.substring(0,16);t=t.substring(16);var f=n.base64ToArrayBuffer(c),u=n.base64ToArrayBuffer(t);cryptoApi.unwrapKey("raw",u,e,{name:e.algorithm.name,iv:f,tagLength:128},{name:r.keyCipher,length:r.keyLength},r.isExtractable,r.keyUsages).then(function(e){o(e)}).catch(function(e){a(e)})}})}},{key:"sign",value:function(e,t,r){var n=this;return new Promise(function(o,a){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("object"!==_typeof(t))throw new TypeError("Expected input of data to be an ArrayBuffer");if("ECDSA"===e.algorithm.name){if(void 0===r&&(r={}),r.hash=void 0!==r.hash?r.hash:"SHA-512","string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:r.hash}},e,t).then(function(e){var t=n.arrayBufferToBase64(e);o(t)})}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Unsupported privateKey");if(void 0===r&&(r={}),r.saltLength=void 0!==r.saltLength?r.saltLength:128,"number"!=typeof r.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:r.saltLength},e,t).then(function(e){var t=n.arrayBufferToBase64(e);o(t)}).catch(function(e){a(e)})}})}},{key:"verify",value:function(e,t,r,n){var o=this;return new Promise(function(a,i){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of signature to be a base64 String");if("object"!==_typeof(r))throw new TypeError("Expected input of data to be an ArrayBuffer");if("ECDSA"===e.algorithm.name){if(void 0===n&&(n={}),n.hash=void 0!==n.hash?n.hash:"SHA-512","string"!=typeof n.hash)throw new TypeError("Expected input of options.hash to be a String");var p=o.base64ToArrayBuffer(t);cryptoApi.verify({name:"ECDSA",hash:{name:n.hash}},e,p,r).then(function(e){a(e)}).catch(function(e){i(e)})}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Unsupported publicKey");var y=o.base64ToArrayBuffer(t);cryptoApi.verify({name:"RSA-PSS",saltLength:128},e,y,r).then(function(e){a(e)}).catch(function(e){i(e)})}})}},{key:"getSharedKey",value:function(e,t){if("number"!=typeof(e=void 0!==e?e:256))throw new TypeError("Expected input of keyLength to be a Number");return new Promise(function(r,n){if(void 0===t&&(t={}),t.keyCipher=void 0!==t.keyCipher?t.keyCipher:"AES-GCM",t.keyUsages=void 0!==t.keyUsages?t.keyUsages:["encrypt","decrypt","wrapKey","unwrapKey"],t.isExtractable=void 0===t.isExtractable||t.isExtractable,"string"!=typeof t.keyCipher)throw new TypeError("Expected input of options.keyCipher expected to be a String");if("object"!==_typeof(t.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");cryptoApi.generateKey({name:t.keyCipher,length:e},t.isExtractable,t.keyUsages).then(function(e){r(e)}).catch(function(e){n(e)})})}},{key:"encrypt",value:function(e,t){var r=this;return new Promise(function(n,o){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!==_typeof(t))throw new TypeError("Expected input of data to be an ArrayBuffer");var a=cryptoLib.getRandomValues(new Uint8Array(12));cryptoApi.encrypt({name:"AES-GCM",iv:a,tagLength:128},e,t).then(function(e){var t=r.arrayBufferToBase64(a),o=r.arrayBufferToBase64(e);n(t+o)}).catch(function(e){o(e)})})}},{key:"decrypt",value:function(e,t){var r=this;return new Promise(function(n,o){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a String");var a=t.substring(0,16),i=t.substring(16),p=r.base64ToArrayBuffer(a),y=r.base64ToArrayBuffer(i);cryptoApi.decrypt({name:"AES-GCM",iv:p,tagLength:128},e,y).then(function(e){n(e)}).catch(function(e){o(e)})})}},{key:"keyFromPassphrase",value:function(e,t,r,n,o){var a=this;return r=void 0!==r?r:64e3,n=void 0!==n?n:"SHA-512",o=void 0!==o?o:256,new Promise(function(i,p){if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("string"!=typeof t)throw new TypeError("Expected input of salt to be a String");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof n)throw new TypeError("Expected input of hash to be a String");if("number"!=typeof o)throw new TypeError("Expected input of length to be a Number");cryptoApi.importKey("raw",a.stringToArrayBuffer(e),{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:a.stringToArrayBuffer(t),iterations:r,hash:n},e,{name:"AES-GCM",length:o},!0,["encrypt","decrypt","wrapKey","unwrapKey"]).then(function(e){cryptoApi.exportKey("raw",e).then(function(e){i(a.arrayBufferToHexString(e))}).catch(function(e){p(e)})}).catch(function(e){p(e)})}).catch(function(e){p(e)})})}},{key:"cryptoKeyToFingerprint",value:function(e,t){var r=this;return t=void 0!==t?t:"SHA-1",new Promise(function(n,o){if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of hash to be a String");var a=null;if("public"===e.type)a="spki";else if("private"===e.type)a="pkcs8";else{if("secret"!==e.type)throw new TypeError("Invalid encryption key");a="raw"}cryptoApi.exportKey(a,e).then(function(e){cryptoApi.digest({name:t},e).then(function(e){n(r.arrayBufferToHexString(e))}).catch(function(e){o(e)})}).catch(function(e){o(e)})})}},{key:"getRandomData",value:function(e){var t=this;return e=void 0!==e?e:16,new Promise(function(r,n){if("number"!=typeof e)throw new TypeError("Expected input of size to be a Number");var o=cryptoLib.getRandomValues(new Uint8Array(e));r(t.arrayBufferToHexString(o))})}}]),e}();