"use strict";function _instanceof(a,b){return null!=b&&"undefined"!=typeof Symbol&&b[Symbol.hasInstance]?!!b[Symbol.hasInstance](a):a instanceof b}function _typeof(a){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _classCallCheck(a,b){if(!_instanceof(a,b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}var cryptoLib=window.crypto||window.msCrypto,cryptoApi=cryptoLib.subtle||cryptoLib.webkitSubtle,chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256),PBES2_OID="06092a864886f70d01050d",PBKDF2_OID="06092a864886f70d01050c",AES256GCM_OID="060960864801650304012e",AES192GCM_OID="060960864801650304011a",AES128GCM_OID="0609608648016503040106",AES256CBC_OID="060960864801650304012a",AES192CBC_OID="0609608648016503040116",AES128CBC_OID="0609608648016503040102",AES256CFB_OID="060960864801650304012c",AES192CFB_OID="0609608648016503040118",AES128CFB_OID="06086086480165030404",SHA512_OID="06082a864886f70d020b0500",SHA384_OID="06082a864886f70d020a0500",SHA256_OID="06082a864886f70d02090500",SHA1_OID="06082a864886f70d02070500",RSA_OID="06092a864886f70d010101",EC_OID="06072a8648ce3d0201",P256_OID="06082a8648ce3d030107",P384_OID="06052b81040022",P521_OID="06052b81040023",OpenCrypto=function(){function a(){_classCallCheck(this,a);for(var b=0;b<chars.length;b++)lookup[chars.charCodeAt(b)]=b}return _createClass(a,[{key:"encodeAb",value:function(a){for(var b=new Uint8Array(a),c=b.length,d="",e=0;e<c;e+=3)d+=chars[b[e]>>2],d+=chars[(3&b[e])<<4|b[e+1]>>4],d+=chars[(15&b[e+1])<<2|b[e+2]>>6],d+=chars[63&b[e+2]];return 2==c%3?d=d.substring(0,d.length-1)+"=":1==c%3&&(d=d.substring(0,d.length-2)+"=="),d}},{key:"decodeAb",value:function(a){var b,c,d,e,f=a.length,g=.75*a.length,h=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);for(var j=new ArrayBuffer(g),k=new Uint8Array(j),l=0;l<f;l+=4)b=lookup[a.charCodeAt(l)],c=lookup[a.charCodeAt(l+1)],d=lookup[a.charCodeAt(l+2)],e=lookup[a.charCodeAt(l+3)],k[h++]=b<<2|c>>4,k[h++]=(15&c)<<4|d>>2,k[h++]=(3&d)<<6|63&e;return j}},{key:"arrayBufferToString",value:function(a){if("object"!==_typeof(a))throw new TypeError("Expected input to be an ArrayBuffer Object");var b=new TextDecoder("utf-8");return b.decode(a)}},{key:"stringToArrayBuffer",value:function(a){if("string"!=typeof a)throw new TypeError("Expected input to be a String");var b=new TextEncoder("utf-8"),c=b.encode(a);return c.buffer}},{key:"arrayBufferToHexString",value:function(a){if("object"!==_typeof(a))throw new TypeError("Expected input to be an ArrayBuffer Object");for(var b,c=new Uint8Array(a),d="",e=0;e<c.byteLength;e++)b=c[e].toString(16),2>b.length&&(b="0"+b),d+=b;return d}},{key:"hexStringToArrayBuffer",value:function(a){if("string"!=typeof a)throw new TypeError("Expected input of hexString to be a String");if(0!=a.length%2)throw new RangeError("Expected string to be an even number of characters");for(var b=new Uint8Array(a.length/2),c=0;c<a.length;c+=2)b[c/2]=parseInt(a.substring(c,c+2),16);return b.buffer}},{key:"arrayBufferToBase64",value:function(a){if("object"!==_typeof(a))throw new TypeError("Expected input to be an ArrayBuffer Object");return this.encodeAb(a)}},{key:"base64ToArrayBuffer",value:function(a){if("string"!=typeof a)throw new TypeError("Expected input to be a base64 String");return this.decodeAb(a)}},{key:"decimalToHex",value:function(a,b){b="undefined"!=typeof b&&b;var c=null;return"number"==typeof a?b?(c=a.toString(16),c.length%2?"000"+c:"00"+c):(c=a.toString(16),c.length%2?"0"+c:c):"string"==typeof a?(c=(a.length/2).toString(16),c.length%2?"0"+c:c):void 0}},{key:"addNewLines",value:function(a){for(var b="";0<a.length;)b+=a.substring(0,64)+"\r\n",a=a.substring(64);return b}},{key:"removeLines",value:function(a){return a.replace(/\r?\n|\r/g,"")}},{key:"toAsn1",value:function(a,b,c,d,e,f,g){a=this.arrayBufferToHexString(a),b=this.arrayBufferToHexString(b),c=this.arrayBufferToHexString(c),d=this.decimalToHex(d,!0);var h={};"SHA-512"===e?h.HASH_OID=SHA512_OID:"SHA-384"===e?h.HASH_OID=SHA384_OID:"SHA-256"===e?h.HASH_OID=SHA256_OID:"SHA-1"===e?h.HASH_OID=SHA1_OID:void 0,"AES-GCM"===f?256===g?h.CIPHER_OID=AES256GCM_OID:192===g?h.CIPHER_OID=AES192GCM_OID:128==g&&(h.CIPHER_OID=AES128GCM_OID):"AES-CBC"===f?256===g?h.CIPHER_OID=AES256CBC_OID:192===g?h.CIPHER_OID=AES192CBC_OID:128==g&&(h.CIPHER_OID=AES128CBC_OID):"AES-CFB"===f?256===g?h.CIPHER_OID=AES256CFB_OID:192===g?h.CIPHER_OID=AES192CFB_OID:128==g&&(h.CIPHER_OID=AES128CFB_OID):void 0;var i="02"+this.decimalToHex(d.length/2)+d,j="04"+this.decimalToHex(b)+b,k="04"+this.decimalToHex(c)+c,l=2==this.decimalToHex(a).length/2?"82":"81",m="04"+l+this.decimalToHex(a)+a;h.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(h.CIPHER_OID+k),h.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(h.HASH_OID),h.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(j+i+h.SEQUENCE_HASH_CONTAINER+h.HASH_OID),h.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(PBKDF2_OID+h.SEQUENCE_PBKDF2_INNER_CONTAINER+j+i+h.SEQUENCE_HASH_CONTAINER+h.HASH_OID),h.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(h.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+h.SEQUENCE_PBKDF2_INNER_CONTAINER+j+i+h.SEQUENCE_HASH_CONTAINER+h.HASH_OID+h.SEQUENCE_AES_CONTAINER+h.CIPHER_OID+k),h.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(PBES2_OID+h.SEQUENCE_PBES2_INNER_CONTAINER+h.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+h.SEQUENCE_PBKDF2_INNER_CONTAINER+j+i+h.SEQUENCE_HASH_CONTAINER+h.HASH_OID+h.SEQUENCE_AES_CONTAINER+h.CIPHER_OID+k);var n=h.SEQUENCE_PBES2_CONTAINER+PBES2_OID+h.SEQUENCE_PBES2_INNER_CONTAINER+h.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+h.SEQUENCE_PBKDF2_INNER_CONTAINER+j+i+h.SEQUENCE_HASH_CONTAINER+h.HASH_OID+h.SEQUENCE_AES_CONTAINER+h.CIPHER_OID+k,o=this.decimalToHex(n+m),p=2==o.length/2?"82":"81",q=this.hexStringToArrayBuffer("30"+p+o+n+m),r=this.arrayBufferToBase64(q);return r=this.addNewLines(r),r="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+r+"-----END ENCRYPTED PRIVATE KEY-----",r}},{key:"fromAsn1",value:function(a){var b={};a=this.removeLines(a),a=a.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----",""),a=a.replace("-----END ENCRYPTED PRIVATE KEY-----",""),a=this.base64ToArrayBuffer(a);var c=this.arrayBufferToHexString(a);b.data=c,b.data.includes(PBES2_OID)&&b.data.includes(PBKDF2_OID)&&(b.valid=!0),b.saltBegin=b.data.indexOf(PBKDF2_OID)+28,b.data.includes(AES256GCM_OID)?(b.cipher="AES-GCM",b.keyLength=256,b.ivBegin=b.data.indexOf(AES256GCM_OID)+24):b.data.includes(AES192GCM_OID)?(b.cipher="AES-GCM",b.keyLength=192,b.ivBegin=b.data.indexOf(AES192GCM_OID)+24):b.data.includes(AES128GCM_OID)?(b.cipher="AES-GCM",b.keyLength=128,b.ivBegin=b.data.indexOf(AES128GCM_OID)+24):b.data.includes(AES256CBC_OID)?(b.cipher="AES-CBC",b.keyLength=256,b.ivBegin=b.data.indexOf(AES256CBC_OID)+24):b.data.includes(AES192CBC_OID)?(b.cipher="AES-CBC",b.keyLength=192,b.ivBegin=b.data.indexOf(AES192CBC_OID)+24):b.data.includes(AES128CBC_OID)?(b.cipher="AES-CBC",b.keyLength=128,b.ivBegin=b.data.indexOf(AES128CBC_OID)+24):b.data.includes(AES256CFB_OID)?(b.cipher="AES-CFB",b.keyLength=256,b.ivBegin=b.data.indexOf(AES256CFB_OID)+24):b.data.includes(AES192CFB_OID)?(b.cipher="AES-CFB",b.keyLength=192,b.ivBegin=b.data.indexOf(AES192CFB_OID)+24):b.data.includes(AES128CFB_OID)&&(b.cipher="AES-CFB",b.keyLength=128,b.ivBegin=b.data.indexOf(AES128CFB_OID)+22),b.data.includes(SHA512_OID)?b.hash="SHA-512":b.data.includes(SHA384_OID)?b.hash="SHA-384":b.data.includes(SHA256_OID)?b.hash="SHA-256":b.data.includes(SHA1_OID)&&(b.hash="SHA-1"),b.saltLength=parseInt(b.data.substr(b.saltBegin,2),16),b.ivLength=parseInt(b.data.substr(b.ivBegin,2),16),b.salt=b.data.substr(b.saltBegin+2,2*b.saltLength),b.iv=b.data.substr(b.ivBegin+2,2*b.ivLength),b.iterBegin=b.saltBegin+4+2*b.saltLength,b.iterLength=parseInt(b.data.substr(b.iterBegin,2),16),b.iter=parseInt(b.data.substr(b.iterBegin+2,2*b.iterLength),16),b.sequencePadding="81"===b.data.substr(2,2)?8:10,b.parametersPadding="81"===b.data.substr(2,2)?12:16,b.sequenceLength=parseInt(b.data.substr(b.sequencePadding,2),16),b.encryptedDataBegin=b.parametersPadding+2*b.sequenceLength,b.encryptedDataPadding="81"===b.data.substr(b.encryptedDataBegin-2,2)?2:4,b.encryptedDataLength=parseInt(b.data.substr(b.encryptedDataBegin,6),16),b.encryptedData=b.data.substr(b.encryptedDataBegin+b.encryptedDataPadding,2*b.encryptedDataLength);var d={salt:this.hexStringToArrayBuffer(b.salt),iv:this.hexStringToArrayBuffer(b.iv),cipher:b.cipher,keyLength:b.keyLength,hash:b.hash,iter:b.iter,encryptedData:this.hexStringToArrayBuffer(b.encryptedData)};return d}},{key:"cryptoPrivateToPem",value:function(a){var b=this;return new Promise(function(c,d){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("pkcs8",a).then(function(a){var d=b.arrayBufferToBase64(a),e=b.addNewLines(d);e="-----BEGIN PRIVATE KEY-----\r\n"+e+"-----END PRIVATE KEY-----",c(e)}).catch(function(a){d(a)})})}},{key:"pemPrivateToCrypto",value:function(a,b){var c=this;return new Promise(function(d,e){if("undefined"==typeof b&&(b={}),b.isExtractable="undefined"==typeof b.isExtractable||b.isExtractable,"string"!=typeof a)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof b.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");a=a.replace("-----BEGIN PRIVATE KEY-----",""),a=a.replace("-----END PRIVATE KEY-----","");var f=c.removeLines(a),g=c.base64ToArrayBuffer(f),h=c.arrayBufferToHexString(g),i=null;if(h.includes(EC_OID)){if(b.name="undefined"==typeof b.name?"ECDH":b.name,"string"!=typeof b.name)throw new TypeError("Expected input of options.name to be a String");var j=null;if(h.includes(P256_OID)?j="P-256":h.includes(P384_OID)?j="P-384":h.includes(P521_OID)&&(j="P-521"),"ECDH"===b.name){if(b.usages="undefined"==typeof b.usages?["deriveKey","deriveBits"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be a String");}else if("ECDSA"!==b.name)throw new TypeError("Invalid algorithm name");else if(b.usages="undefined"==typeof b.usages?["sign"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be a String");i={name:b.name,namedCurve:j}}else if(h.includes(RSA_OID)){if(b.name="undefined"==typeof b.name?"RSA-OAEP":b.name,b.hash="undefined"==typeof b.hash?"SHA-512":b.hash,"string"!=typeof b.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof b.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===b.name){if(b.usages="undefined"==typeof b.usages?["decrypt","unwrapKey"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be an Array");}else if("RSA-PSS"!==b.name)throw new TypeError("Invalid algorithm name");else if(b.usages="undefined"==typeof b.usages?["sign"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be a String");i={name:b.name,hash:{name:b.hash}}}else throw new TypeError("Invalid private key");cryptoApi.importKey("pkcs8",g,i,b.isExtractable,b.usages).then(function(a){d(a)}).catch(function(a){e(a)})})}},{key:"cryptoPublicToPem",value:function(a){var b=this;return new Promise(function(c,d){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"public"!==a.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("spki",a).then(function(a){var d=b.arrayBufferToBase64(a),e=b.addNewLines(d);e="-----BEGIN PUBLIC KEY-----\r\n"+e+"-----END PUBLIC KEY-----",c(e)}).catch(function(a){d(a)})})}},{key:"pemPublicToCrypto",value:function(a,b){var c=this;return new Promise(function(d,e){if("undefined"==typeof b&&(b={}),b.isExtractable="undefined"==typeof b.isExtractable||b.isExtractable,"string"!=typeof a)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof b.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a String");a=a.replace("-----BEGIN PUBLIC KEY-----",""),a=a.replace("-----END PUBLIC KEY-----","");var f=c.removeLines(a),g=c.base64ToArrayBuffer(f),h=c.arrayBufferToHexString(g),i=null;if(h.includes(EC_OID)){if(b.name="undefined"==typeof b.name?"ECDH":b.name,"string"!=typeof b.name)throw new TypeError("Expected input of options.name to be a String");var j=null;if(h.includes(P256_OID)?j="P-256":h.includes(P384_OID)?j="P-384":h.includes(P521_OID)&&(j="P-521"),"ECDH"===b.name){if(b.usages="undefined"==typeof b.usages?[]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be a String");}else if("ECDSA"!==b.name)throw new TypeError("Invalid algorithm name");else if(b.usages="undefined"==typeof b.usages?["verify"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be a String");i={name:b.name,namedCurve:j}}else if(h.includes(RSA_OID)){if(b.name="undefined"==typeof b.name?"RSA-OAEP":b.name,b.hash="undefined"==typeof b.hash?"SHA-512":b.hash,"string"!=typeof b.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof b.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===b.name){if(b.usages="undefined"==typeof b.usages?["encrypt","wrapKey"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be an Array");}else if("RSA-PSS"!==b.name)throw new TypeError("Invalid algorithm name");else if(b.usages="undefined"==typeof b.usages?["verify"]:b.usages,"object"!==_typeof(b.usages))throw new TypeError("Expected input of options.usages to be an Array");i={name:b.name,hash:{name:b.hash}}}else throw new TypeError("Invalid public key");cryptoApi.importKey("spki",g,i,b.isExtractable,b.usages).then(function(a){d(a)}).catch(function(a){e(a)})})}},{key:"getRSAKeyPair",value:function(a,b,c,d,e){return a="undefined"==typeof a?2048:a,b="undefined"==typeof b?"SHA-512":b,c="undefined"==typeof c?"RSA-OAEP":c,d="undefined"==typeof d?["encrypt","decrypt","wrapKey","unwrapKey"]:d,e="undefined"==typeof e||e,new Promise(function(f,g){if("number"!=typeof a)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof b)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof c)throw new TypeError("Expected input of paddingScheme to be a String");if("object"!==_typeof(d))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof e)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:c,modulusLength:a,publicExponent:new Uint8Array([1,0,1]),hash:{name:b}},e,d).then(function(a){f(a)}).catch(function(a){g(a)})})}},{key:"rsaEncrypt",value:function(a,b){var c=this;return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"public"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type public");if("object"!==_typeof(b))throw new TypeError("Expected input of data to be an ArrayBuffer");cryptoApi.encrypt({name:"RSA-OAEP"},a,b).then(function(a){d(c.arrayBufferToBase64(a))}).catch(function(a){e(a)})})}},{key:"rsaDecrypt",value:function(a,b){var c=this;return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type private");if("string"!=typeof b)throw new TypeError("Expected input of encryptedData to be a String");cryptoApi.decrypt({name:"RSA-OAEP"},a,c.base64ToArrayBuffer(b)).then(function(a){d(a)}).catch(function(a){e(a)})})}},{key:"getECKeyPair",value:function(a,b,c,d){return a="undefined"==typeof a?"P-256":a,b="undefined"==typeof b?"ECDH":b,c="undefined"==typeof c?["deriveKey","deriveBits"]:c,d="undefined"==typeof d||d,new Promise(function(e,f){if("string"!=typeof a)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof b)throw new TypeError("Expected input of type to be a String");if("object"!==_typeof(c))throw new TypeError("Expected input of usages to be an Array");if("boolean"!=typeof d)throw new TypeError("Expected input of isExtractable to be a Boolean");cryptoApi.generateKey({name:b,namedCurve:a},d,c).then(function(a){e(a)}).catch(function(a){f(a)})})}},{key:"encryptPrivateKey",value:function(a,b,c,d,e,f){var g=this;return c="undefined"==typeof c?64e3:c,d="undefined"==typeof d?"SHA-512":d,e="undefined"==typeof e?"AES-GCM":e,f="undefined"==typeof f?256:f,new Promise(function(h,i){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("string"!=typeof b)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof c)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof d)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof e)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof f)throw new TypeError("Expected input of keyLength to be a Number");var j=null;"AES-GCM"===e?j=12:"AES-CBC"===e?j=16:"AES-CFB"==e&&(j=16);var k=cryptoLib.getRandomValues(new Uint8Array(16)),l=cryptoLib.getRandomValues(new Uint8Array(j));cryptoApi.importKey("raw",g.stringToArrayBuffer(b),{name:"PBKDF2"},!1,["deriveKey"]).then(function(b){cryptoApi.deriveKey({name:"PBKDF2",salt:k,iterations:c,hash:d},b,{name:e,length:f},!0,["wrapKey"]).then(function(b){cryptoApi.wrapKey("pkcs8",a,b,{name:e,iv:l,tagLength:128}).then(function(a){var b=g.toAsn1(a,k,l,c,d,e,f);h(b)}).catch(function(a){i(a)})}).catch(function(a){i(a)})}).catch(function(a){i(a)})})}},{key:"decryptPrivateKey",value:function(a,b,c){var d=this,e=this.fromAsn1(a);return new Promise(function(f,g){"undefined"==typeof c&&(c={});var h={};if(c.name="undefined"==typeof c.name?"ECDH":c.name,c.isExtractable="undefined"==typeof c.isExtractable||c.isExtractable,h.name=c.name,"ECDH"===c.name){if(c.namedCurve="undefined"==typeof c.namedCurve?"P-256":c.namedCurve,c.keyUsages="undefined"==typeof c.keyUsages?["deriveKey","deriveBits"]:c.keyUsages,h.namedCurve=c.namedCurve,"string"!=typeof c.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String");}else if("ECDSA"===c.name){if(c.namedCurve="undefined"==typeof c.namedCurve?"P-256":c.namedCurve,c.keyUsages="undefined"==typeof c.keyUsages?["sign"]:c.keyUsages,h.namedCurve=c.namedCurve,"string"!=typeof c.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a base64 String");}else if("RSA-OAEP"===c.name){if(c.hash="undefined"==typeof c.hash?{}:c.hash,c.hash.name="undefined"==typeof c.hash.name?"SHA-512":c.hash.name,c.keyUsages="undefined"==typeof c.keyUsages?["decrypt","unwrapKey"]:c.keyUsages,h.hash={},h.hash.name=c.hash.name,"string"!=typeof c.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String");}else if("RSA-PSS"!==c.name)throw new TypeError("Unsupported encryptedPrivateKey");else if(c.hash="undefined"==typeof c.hash?{}:c.hash,c.hash.name="undefined"==typeof c.hash.name?"SHA-512":c.hash.name,c.keyUsages="undefined"==typeof c.keyUsages?["sign"]:c.keyUsages,h.hash={},h.hash.name=c.hash.name,"string"!=typeof c.hash.name)throw new TypeError("Expected input of options.hash.name to be a base64 String");if("string"!=typeof a)throw new TypeError("Expected input of encryptedPrivateKey to be a base64 String");if("string"!=typeof b)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(c.keyUsages))throw new TypeError("Expected input of options.keyUsages to be a String");if("boolean"!=typeof c.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.importKey("raw",d.stringToArrayBuffer(b),{name:"PBKDF2"},!1,["deriveKey"]).then(function(a){cryptoApi.deriveKey({name:"PBKDF2",salt:e.salt,iterations:e.iter,hash:e.hash},a,{name:e.cipher,length:e.keyLength},!1,["unwrapKey"]).then(function(a){cryptoApi.unwrapKey("pkcs8",e.encryptedData,a,{name:e.cipher,iv:e.iv,tagLength:128},h,c.isExtractable,c.keyUsages).then(function(a){f(a)}).catch(function(a){g(a)})}).catch(function(a){g(a)})}).catch(function(a){g(a)})})}},{key:"keyAgreement",value:function(a,b,c){return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(b)&&"public"!==b.type)throw new TypeError("Expected input of publicKey to be a CryptoKey of type public");if("undefined"==typeof c&&(c={}),c.bitLength="undefined"==typeof c.bitLength?256:c.bitLength,c.hkdfHash="undefined"==typeof c.hkdfHash?"SHA-512":c.hkdfHash,c.hkdfSalt="undefined"==typeof c.hkdfSalt?new Uint8Array:c.hkdfSalt,c.hkdfInfo="undefined"==typeof c.hkdfInfo?new Uint8Array:c.hkdfInfo,c.keyCipher="undefined"==typeof c.keyCipher?"AES-GCM":c.keyCipher,c.keyLength="undefined"==typeof c.keyLength?256:c.keyLength,c.keyUsages="undefined"==typeof c.keyUsages?["encrypt","decrypt","unwrapKey","wrapKey"]:c.keyUsages,c.isExtractable="undefined"==typeof c.isExtractable||c.isExtractable,"number"!=typeof c.bitLength)throw new TypeError("Expected input of options.bitLength to be a Number");if("string"!=typeof c.hkdfHash)throw new TypeError("Expected input of options.hkdfHash to be a String");if("object"!==_typeof(c.hkdfSalt))throw new TypeError("Expected input of options.hkdfSalt to be an ArrayBuffer");if("object"!==_typeof(c.hkdfInfo))throw new TypeError("Expected input of options.hkdfInfo to be an ArrayBuffer");if("string"!=typeof c.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof c.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(c.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof c.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.deriveBits({name:"ECDH",namedCurve:b.algorithm.namedCurve,public:b},a,c.bitLength).then(function(a){cryptoApi.importKey("raw",a,{name:"HKDF"},!1,["deriveKey"]).then(function(a){cryptoApi.deriveKey({name:"HKDF",hash:{name:c.hkdfHash},salt:c.hkdfSalt,info:c.hkdfInfo},a,{name:c.keyCipher,length:c.keyLength},c.isExtractable,c.keyUsages).then(function(a){d(a)}).catch(function(a){e(a)})}).catch(function(a){e(a)})}).catch(function(a){e(a)})})}},{key:"encryptKey",value:function(a,b){var c=this;return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a))throw new TypeError("Expected input of wrappingKey to be a CryptoKey");if("[object CryptoKey]"!==Object.prototype.toString.call(b)&&"secret"!==b.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey of type secret");if("secret"===a.type){var f=null;f="AES-GCM"===a.algorithm.name?cryptoLib.getRandomValues(new Uint8Array(12)):cryptoLib.getRandomValues(new Uint8Array(16)),cryptoApi.wrapKey("raw",b,a,{name:a.algorithm.name,iv:f,tagLength:128}).then(function(a){d(c.arrayBufferToBase64(f)+c.arrayBufferToBase64(a))}).catch(function(a){e(a)})}else if("RSA-OAEP"===a.algorithm.name){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"public"!==a.type)throw new TypeError("Expected input of wrappingKey using RSA-OAEP to be a CryptoKey of type public");cryptoApi.wrapKey("raw",b,a,{name:"RSA-OAEP",hash:{name:a.algorithm.hash.name}}).then(function(a){d(c.arrayBufferToBase64(a))}).catch(function(a){e(a)})}else throw new TypeError("Unsupported wrappingKey")})}},{key:"decryptKey",value:function(a,b,c){var d=this;return new Promise(function(e,f){if("[object CryptoKey]"!==Object.prototype.toString.call(a))throw new TypeError("Expected input of unwrappingKey to be a CryptoKey");if("string"!=typeof b)throw new TypeError("Expected input of encryptedSharedKey to be a base64 String");if("undefined"==typeof c&&(c={}),c.keyCipher="undefined"==typeof c.keyCipher?"AES-GCM":c.keyCipher,c.keyLength="undefined"==typeof c.keyLength?256:c.keyLength,c.keyUsages="undefined"==typeof c.keyUsages?["encrypt","decrypt","wrapKey","unwrapKey"]:c.keyUsages,c.isExtractable="undefined"==typeof c.isExtractable||c.isExtractable,"string"!=typeof c.keyCipher)throw new TypeError("Expected input of options.keyCipher to be a String");if("number"!=typeof c.keyLength)throw new TypeError("Expected input of options.keyLength to be a Number");if("object"!==_typeof(c.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof c.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");if("secret"===a.type){var g=null,h=null;"AES-GCM"===a.algorithm.name?(g=b.substring(0,16),h=b.substring(16)):(g=b.substring(0,24),h=b.substring(24));var i=d.base64ToArrayBuffer(g),j=d.base64ToArrayBuffer(h);cryptoApi.unwrapKey("raw",j,a,{name:a.algorithm.name,iv:i,tagLength:128},{name:c.keyCipher,length:c.keyLength},c.isExtractable,c.keyUsages).then(function(a){e(a)}).catch(function(a){f(a)})}else if("RSA-OAEP"===a.algorithm.name){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey of type private");var k=d.base64ToArrayBuffer(b);cryptoApi.unwrapKey("raw",k,a,{name:"RSA-OAEP",modulusLength:a.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:a.algorithm.hash.name}},{name:c.keyCipher,length:c.keyLength},c.isExtractable,c.keyUsages).then(function(a){e(a)}).catch(function(a){f(a)})}else throw new TypeError("Unsupported unwrappingKey")})}},{key:"sign",value:function(a,b,c){var d=this;return new Promise(function(e,f){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"private"!==a.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object");if("object"!==_typeof(b))throw new TypeError("Expected input of data to be an ArrayBuffer");if("undefined"==typeof c&&(c={}),c.isBuffer="undefined"!=typeof c.isBuffer&&c.isBuffer,"boolean"!=typeof c.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");if("ECDSA"===a.algorithm.name){if(c.hash="undefined"==typeof c.hash?"SHA-512":c.hash,"string"!=typeof c.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:c.hash}},a,b).then(function(a){if(isBuffer)e(a);else{var b=d.arrayBufferToBase64(a);e(b)}})}else if("RSA-PSS"===a.algorithm.name){if(c.saltLength="undefined"==typeof c.saltLength?128:c.saltLength,"number"!=typeof c.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:c.saltLength},a,b).then(function(a){if(c.isBuffer)e(a);else{var b=d.arrayBufferToBase64(a);e(b)}}).catch(function(a){f(a)})}else throw new TypeError("Unsupported privateKey")})}},{key:"verify",value:function(a,b,c,d){var e=this;return new Promise(function(f,g){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"public"!==a.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object");if("undefined"==typeof d&&(d={}),d.isBuffer="undefined"!=typeof d.isBuffer&&d.isBuffer,"boolean"!=typeof d.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");if(d.isBuffer&&"object"!==_typeof(b))throw new TypeError("Expected input of signature to be an ArrayBuffer");if(!1===d.isBuffer&&"string"!=typeof b)throw new TypeError("Expected input of signature to be a base64 String");if("object"!==_typeof(c))throw new TypeError("Expected input of data to be an ArrayBuffer");var h=b;if(!1===d.isBuffer&&(h=e.base64ToArrayBuffer(b)),"ECDSA"===a.algorithm.name){if(d.hash="undefined"==typeof d.hash?"SHA-512":d.hash,"string"!=typeof d.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:d.hash}},a,h,c).then(function(a){f(a)}).catch(function(a){g(a)})}else if("RSA-PSS"===a.algorithm.name)cryptoApi.verify({name:"RSA-PSS",saltLength:128},a,h,c).then(function(a){f(a)}).catch(function(a){g(a)});else throw new TypeError("Unsupported publicKey")})}},{key:"getSharedKey",value:function(a,b){if(a="undefined"==typeof a?256:a,"number"!=typeof a)throw new TypeError("Expected input of keyLength to be a Number");return new Promise(function(c,d){if("undefined"==typeof b&&(b={}),b.keyCipher="undefined"==typeof b.keyCipher?"AES-GCM":b.keyCipher,b.keyUsages="undefined"==typeof b.keyUsages?["encrypt","decrypt","wrapKey","unwrapKey"]:b.keyUsages,b.isExtractable="undefined"==typeof b.isExtractable||b.isExtractable,"string"!=typeof b.keyCipher)throw new TypeError("Expected input of options.keyCipher expected to be a String");if("object"!==_typeof(b.keyUsages))throw new TypeError("Expected input of options.keyUsages to be an Array");if("boolean"!=typeof b.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");cryptoApi.generateKey({name:b.keyCipher,length:a},b.isExtractable,b.keyUsages).then(function(a){c(a)}).catch(function(a){d(a)})})}},{key:"encrypt",value:function(a,b){var c=this;return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"secret"!==a.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!==_typeof(b))throw new TypeError("Expected input of data to be an ArrayBuffer");var f=cryptoLib.getRandomValues(new Uint8Array(12));cryptoApi.encrypt({name:"AES-GCM",iv:f,tagLength:128},a,b).then(function(a){var b=c.arrayBufferToBase64(f),e=c.arrayBufferToBase64(a);d(b+e)}).catch(function(a){e(a)})})}},{key:"decrypt",value:function(a,b){var c=this;return new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a)&&"secret"!==a.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof b)throw new TypeError("Expected input of encryptedData to be a String");var f=b.substring(0,16),g=b.substring(16),h=c.base64ToArrayBuffer(f),i=c.base64ToArrayBuffer(g);cryptoApi.decrypt({name:"AES-GCM",iv:h,tagLength:128},a,i).then(function(a){d(a)}).catch(function(a){e(a)})})}},{key:"keyFromPassphrase",value:function(a,b,c,d,e){var f=this;return c="undefined"==typeof c?64e3:c,d="undefined"==typeof d?"SHA-512":d,e="undefined"==typeof e?256:e,new Promise(function(g,h){if("string"!=typeof a)throw new TypeError("Expected input of passphrase to be a String");if("string"!=typeof b)throw new TypeError("Expected input of salt to be a String");if("number"!=typeof c)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof d)throw new TypeError("Expected input of hash to be a String");if("number"!=typeof e)throw new TypeError("Expected input of length to be a Number");cryptoApi.importKey("raw",f.stringToArrayBuffer(a),{name:"PBKDF2"},!1,["deriveKey"]).then(function(a){cryptoApi.deriveKey({name:"PBKDF2",salt:f.stringToArrayBuffer(b),iterations:c,hash:d},a,{name:"AES-GCM",length:e},!0,["encrypt","decrypt","wrapKey","unwrapKey"]).then(function(a){cryptoApi.exportKey("raw",a).then(function(a){g(f.arrayBufferToHexString(a))}).catch(function(a){h(a)})}).catch(function(a){h(a)})}).catch(function(a){h(a)})})}},{key:"cryptoKeyToFingerprint",value:function(a,b){var c=this;return b="undefined"==typeof b?"SHA-1":b,new Promise(function(d,e){if("[object CryptoKey]"!==Object.prototype.toString.call(a))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof b)throw new TypeError("Expected input of hash to be a String");var f=null;if("public"===a.type)f="spki";else if("private"===a.type)f="pkcs8";else if("secret"===a.type)f="raw";else throw new TypeError("Invalid encryption key");cryptoApi.exportKey(f,a).then(function(a){cryptoApi.digest({name:b},a).then(function(a){d(c.arrayBufferToHexString(a))}).catch(function(a){e(a)})}).catch(function(a){e(a)})})}},{key:"getRandomBytes",value:function(a){this;return a="undefined"==typeof a?16:a,new Promise(function(b){if("number"!=typeof a)throw new TypeError("Expected input of size to be a Number");var c=cryptoLib.getRandomValues(new Uint8Array(a));b(c)})}}]),a}();